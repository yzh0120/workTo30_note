/* 
https://blog.csdn.net/qq_16525279/article/details/127764231

https://www.cnblogs.com/luckest/p/16656933.html

JS 是单线程的”指的是执行 JS 代码的线程只有一个，是浏览器提供的 JS 引擎线程（主线程）。浏览器中还有定时器线程和 HTTP 请求线程等，这些线程主要不是来跑 JS 代码的
 
 
 JS 是单线程的”指的是 在浏览器中执行 JS 代码的线程只有一个, ,但是浏览器中还有定时器线程和 HTTP 请求线程等
 
 
 js是单线程的编程语言，只能同一时间内做一件事，按顺序来处理事件
 
 
 在浏览器中负责执行js代码的线程只有一个,所以js只能同一时间内做一件事,但是浏览器中还有定时器线程和 HTTP 请求线程等
 js解析代码的时候,会将同步代码按顺序排在[执行栈],然后依次执行里面的代码
 遇到异步任务时就交给其他线程处理,异步任务完成后会推入[任务队列]
 等到[执行栈]里面所有的函数都执行完毕后,会从任务队列中去取出已完成的异步任务的回调加入[执行栈]继续执行
 如此循环往复,而每一次循环就是一个事件周期或称为一次 tick
 
 异步任务也分为宏任务和微任务
  常见的宏任务是 setTimeout、setInterval、I/O流
  常见的微任务是 Promise
  微任务先于宏任务执行, 微任务在下一轮DOM渲染前执行，宏任务在下一轮DOM渲染之后执行
 */

/* 
 
 事件循环是用来实现异步特性的。
 
 事件循环中的几个概念：
 
 主线程：
 
 理解为同步任务的先进先出，一旦调用，同步任务就执行。
 执行栈：
 
 先入后出的数据结构，一个任务来到栈底就立即执行，然后释放。
 任务队列：
 
 包括宏任务队列和微任务队列，当执行栈空的时候，就会从任务队列中，取任务来执行。
 宏任务和微任务：
 
 异步任务，通常在主线程执行完同步任务完成之后，才会来执行宏任务和微任务。微任务的优先级要比宏任务高。
 
 常见的宏任务：
 
 script（全局任务）、setTimeout、setInterval、setImmediate、I/O、UI Rendering。
 常见的微任务：
 
 Process.nextTick、Promise、Object.observer、MutationObserver、queueMicrotask（将函数添加到微任务队列）
 注意：new Promise的过程属于同步任务，resolve或者reject之后才算微任务。
 
 -----------------------------------------
 在实际开发中，往往是同步代码和异步代码都有。在js执行时，还是从第一行代码开始执行，遇到函数就将其添加到栈中，然后执行同步操作；如果遇到异步函数，则根据其类型，
 宏任务就添加到宏任务队列，微任务添加到微任务队列。直到同步代码执行完毕，则开始执行异步操作。
 
 异步操作后于同步操作，异步操作内部也是分先后顺序的。总的来说：
 
 微任务先于宏任务执行
 微任务与微任务之间根据先后顺序执行，宏任务与宏任务之间根据延迟时间顺序执行
 微任务在下一轮DOM渲染前执行，宏任务在下一轮DOM渲染之后执行
 每个任务的执行都是一次出栈操作，直到栈被清空
 */