将具体的类型参数化(形参化,模糊化),在调用的时候具体化的类型
泛型可用在 类 方法 接口中  -->  泛型类  泛型方法  泛型接口

泛型定义格式:
<类型一> 指定一种格式的泛型,这里的类型可以看成形参
<类型一,类型二>指定多种类型的泛型
将来具体调用的时候可以看成实参 ,并且实参的类型只能是引用数据类型
------------------------------------------------------------------
泛型类定义格式:
修饰符 class  类名<类型>{
	
}

public class Demo<T>{//T是随便写的任意标识  T E K V 常用于标识泛型
	private T age;
}

public class Demo<T>{
	public void show(T t){
		
	}
}
------------------------------------------------------------------
泛型方法(是不是泛型类没有关系)
public class Demo{
	public <T> void show(T t){
		
	}
}
------------------------------------------------------------------
泛型接口
修饰符 interface  接口名<类型>{
	
}
实现类
public class 实现类名<T> implements 接口名<T>{
	
} 
------------------------------------------------------------------
类型通配符 <?>
List<?> 表示元素类型位置的List,它的元素可以匹配任何的类型
这种带通配符的List仅表示它是各种泛型的父类,并不能把元素添加到其中
如果说我们不希望List<?>是任何泛型的父类,只希望它代表某一类泛型的父类,可以使用类型通配符的上限
<? extends 类型>  <? extends Number> : 它表示的类型是Number或者其子类型

通配符的下限
<? super 类型>    <? super Number> : 它表示的类型是Number或者其父类型


因此使用通配符的基本原则：

如果参数化类型表示一个 T 的生产者，使用 < ? extends T>;
如果它表示一个 T 的消费者，就使用 < ? super T>；
如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。
小总结一下：

T 的生产者的意思就是结果会返回 T，这就要求返回一个具体的类型，必须有上限才够具体；
T 的消费者的意思是要操作 T，这就要求操作的容器要够大，所以容器需要是 T 的父类，即 super T；
------------------------------------------------------------------
java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一
https://www.cnblogs.com/coprince/p/8603492.html